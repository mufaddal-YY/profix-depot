"use strict";
var require$$0 = require("react");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var require$$0__default = /* @__PURE__ */ _interopDefaultCompat(require$$0);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var reactFastCompare, hasRequiredReactFastCompare;
function requireReactFastCompare() {
  if (hasRequiredReactFastCompare) return reactFastCompare;
  hasRequiredReactFastCompare = 1;
  var hasElementType = typeof Element < "u", hasMap = typeof Map == "function", hasSet = typeof Set == "function", hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
  function equal(a, b) {
    if (a === b) return !0;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return !1;
      var length, i, keys;
      if (Array.isArray(a)) {
        if (length = a.length, length != b.length) return !1;
        for (i = length; i-- !== 0; )
          if (!equal(a[i], b[i])) return !1;
        return !0;
      }
      var it;
      if (hasMap && a instanceof Map && b instanceof Map) {
        if (a.size !== b.size) return !1;
        for (it = a.entries(); !(i = it.next()).done; )
          if (!b.has(i.value[0])) return !1;
        for (it = a.entries(); !(i = it.next()).done; )
          if (!equal(i.value[1], b.get(i.value[0]))) return !1;
        return !0;
      }
      if (hasSet && a instanceof Set && b instanceof Set) {
        if (a.size !== b.size) return !1;
        for (it = a.entries(); !(i = it.next()).done; )
          if (!b.has(i.value[0])) return !1;
        return !0;
      }
      if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        if (length = a.length, length != b.length) return !1;
        for (i = length; i-- !== 0; )
          if (a[i] !== b[i]) return !1;
        return !0;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf == "function" && typeof b.valueOf == "function") return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString && typeof a.toString == "function" && typeof b.toString == "function") return a.toString() === b.toString();
      if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
      if (hasElementType && a instanceof Element) return !1;
      for (i = length; i-- !== 0; )
        if (!((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) && !equal(a[keys[i]], b[keys[i]]))
          return !1;
      return !0;
    }
    return a !== a && b !== b;
  }
  return reactFastCompare = function(a, b) {
    try {
      return equal(a, b);
    } catch (error) {
      if ((error.message || "").match(/stack|recursion/i))
        return console.warn("react-fast-compare cannot handle circular refs"), !1;
      throw error;
    }
  }, reactFastCompare;
}
var reactFastCompareExports = requireReactFastCompare(), isFastEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompareExports), withSelector = { exports: {} }, useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_production;
function requireUseSyncExternalStoreWithSelector_production() {
  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
  hasRequiredUseSyncExternalStoreWithSelector_production = 1;
  var React = require$$0__default.default;
  function is(x, y) {
    return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
  return useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (instRef.current === null) {
      var inst = { hasValue: !1, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    return useEffect(
      function() {
        inst.hasValue = !0, inst.value = value;
      },
      [value]
    ), useDebugValue(value), value;
  }, useSyncExternalStoreWithSelector_production;
}
var useSyncExternalStoreWithSelector_development = {};
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_development;
function requireUseSyncExternalStoreWithSelector_development() {
  return hasRequiredUseSyncExternalStoreWithSelector_development || (hasRequiredUseSyncExternalStoreWithSelector_development = 1, process.env.NODE_ENV !== "production" && function() {
    function is(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = require$$0__default.default, objectIs = typeof Object.is == "function" ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    useSyncExternalStoreWithSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef(null);
      if (instRef.current === null) {
        var inst = { hasValue: !1, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
          }
          var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual]
      );
      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
      return useEffect(
        function() {
          inst.hasValue = !0, inst.value = value;
        },
        [value]
      ), useDebugValue(value), value;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), useSyncExternalStoreWithSelector_development;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  return hasRequiredWithSelector || (hasRequiredWithSelector = 1, process.env.NODE_ENV === "production" ? withSelector.exports = requireUseSyncExternalStoreWithSelector_production() : withSelector.exports = requireUseSyncExternalStoreWithSelector_development()), withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const defineStoreContext = require$$0.createContext(null);
function useLiveQuery(initialData, query, queryParams, options) {
  const { isEqual = isFastEqual } = options || {}, defineStore = require$$0.useContext(defineStoreContext), params = useQueryParams(queryParams), noStore = require$$0.useMemo(
    () => ({
      subscribe: () => () => {
      },
      getSnapshot: () => initialData
    }),
    [initialData]
  ), store = require$$0.useMemo(
    () => defineStore?.(initialData, query, params) || {
      subscribe: () => () => {
      },
      getSnapshot: () => initialData
    },
    [defineStore, initialData, params, query]
  ), [serverSnapshot] = require$$0.useState(() => {
    if (initialData === void 0)
      throw new Error(
        "initialSnapshot can't be undefined, if you don't want an initial value use null instead"
      );
    try {
      return JSON.parse(JSON.stringify(initialData));
    } catch (error) {
      return console.warn(
        "Failed to deep clone initialSnapshot, this is likely an error and an indication that the snapshot isn't JSON serializable",
        { initialSnapshot: initialData, error }
      ), initialData;
    }
  }), getServerSnapshot = require$$0.useCallback(() => serverSnapshot, [serverSnapshot]), selector = require$$0.useCallback((snapshot2) => snapshot2, []), snapshot = withSelectorExports.useSyncExternalStoreWithSelector(
    store?.subscribe || noStore.subscribe,
    store?.getSnapshot || noStore.getSnapshot,
    getServerSnapshot,
    selector,
    isEqual
  ), enabled = defineStore !== null;
  return [snapshot, enabled && serverSnapshot === snapshot, enabled];
}
function useIsEnabled() {
  return require$$0.useContext(defineStoreContext) !== null;
}
function useQueryParams(params) {
  const stringifiedParams = require$$0.useMemo(() => JSON.stringify(params || {}), [params]);
  return require$$0.useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
function useRevalidate(props) {
  const { refreshInterval } = props, shouldPause = useShouldPause(), [state, setState] = require$$0.useState("hit"), startRefresh = require$$0.useCallback(() => (setState("inflight"), () => setState("hit")), []);
  return require$$0.useEffect(() => {
    if (!refreshInterval || state !== "hit")
      return;
    const timeout = setTimeout(() => setState("stale"), refreshInterval);
    return () => clearTimeout(timeout);
  }, [refreshInterval, state]), require$$0.useEffect(() => {
    if (state !== "hit")
      return;
    const onFocus = () => setState("stale");
    return window.addEventListener("focus", onFocus), () => window.removeEventListener("focus", onFocus);
  }, [refreshInterval, state]), require$$0.useEffect(() => {
    shouldPause && state === "hit" && setState("stale"), !shouldPause && state === "stale" && setState("refresh");
  }, [shouldPause, state]), [state, startRefresh];
}
function useShouldPause() {
  const [online, setOnline] = require$$0.useState(!1);
  require$$0.useEffect(() => {
    setOnline(navigator.onLine);
    const online2 = () => setOnline(!0), offline = () => setOnline(!1);
    return window.addEventListener("online", online2), window.addEventListener("offline", offline), () => {
      window.removeEventListener("online", online2), window.removeEventListener("offline", offline);
    };
  }, []);
  const visibilityState = require$$0.useSyncExternalStore(
    onVisibilityChange,
    () => document.visibilityState,
    () => "hidden"
  );
  return !online || visibilityState === "hidden";
}
function onVisibilityChange(onStoreChange) {
  return document.addEventListener("visibilitychange", onStoreChange), () => document.removeEventListener("visibilitychange", onStoreChange);
}
exports.defineStoreContext = defineStoreContext;
exports.useIsEnabled = useIsEnabled;
exports.useLiveQuery = useLiveQuery;
exports.useQueryParams = useQueryParams;
exports.useRevalidate = useRevalidate;
//# sourceMappingURL=hooks.cjs.map
