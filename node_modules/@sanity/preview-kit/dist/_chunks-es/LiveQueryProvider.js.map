{"version":3,"file":"LiveQueryProvider.js","sources":["../../../../node_modules/.pnpm/@vercel+stega@0.1.2/node_modules/@vercel/stega/dist/index.mjs","../../../../node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/esm/index.js","../../src/LiveQueryProvider/usePerspective.ts","../../src/LiveQueryProvider/LiveQueryProvider.tsx"],"sourcesContent":["var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import type {ClientPerspective} from '@sanity/client'\nimport {createNode, createNodeMachine} from '@sanity/comlink'\nimport {\n  createCompatibilityActors,\n  type LoaderControllerMsg,\n  type LoaderNodeMsg,\n} from '@sanity/presentation-comlink'\nimport {useEffect, useState} from 'react'\n\nexport function usePerspective(\n  initialPerspective: Exclude<ClientPerspective, 'raw'>,\n): Exclude<ClientPerspective, 'raw'> {\n  const [presentationPerspective, setPresentationPerspective] = useState<Exclude<\n    ClientPerspective,\n    'raw'\n  > | null>(null)\n\n  useEffect(() => {\n    const comlink = createNode<LoaderNodeMsg, LoaderControllerMsg>(\n      {\n        name: 'loaders',\n        connectTo: 'presentation',\n      },\n      createNodeMachine<LoaderNodeMsg, LoaderControllerMsg>().provide({\n        actors: createCompatibilityActors<LoaderNodeMsg>(),\n      }),\n    )\n\n    comlink.on('loader/perspective', (data) => {\n      if (data.perspective !== 'raw') {\n        setPresentationPerspective(data.perspective)\n      }\n    })\n\n    const stop = comlink.start()\n    return () => stop()\n  }, [])\n  return presentationPerspective === null ? initialPerspective : presentationPerspective\n}\n","import type {\n  ClientConfig,\n  ClientPerspective,\n  ContentSourceMap,\n  ContentSourceMapDocuments,\n  QueryParams,\n  SanityClient,\n  SanityDocument,\n} from '@sanity/client'\nimport {applySourceDocuments} from '@sanity/client/csm'\nimport {vercelStegaSplit} from '@vercel/stega'\nimport {LRUCache} from 'lru-cache'\nimport {applyPatch} from 'mendoza'\nimport {startTransition, useCallback, useEffect, useMemo, useState} from 'react'\n\nimport {defineStoreContext as Context} from '../context'\nimport {useRevalidate} from '../hooks'\nimport type {\n  DefineListenerContext,\n  ListenerGetSnapshot,\n  ListenerSubscribe,\n  LiveQueryProviderProps,\n} from '../types'\nimport {usePerspective} from './usePerspective'\n\nconst DEFAULT_TAG = 'sanity.preview-kit'\n\n// Documents share the same cache even if there are nested providers, with a Least Recently Used (LRU) cache\nconst documentsCache = new LRUCache<ReturnType<typeof getTurboCacheKey>, SanityDocument>({\n  // Max 500 documents in memory, no big deal if a document is evicted it just means the eventual consistency might take longer\n  max: 500,\n})\n\n/**\n * @internal\n */\nexport default function LiveStoreProvider(props: LiveQueryProviderProps): React.JSX.Element {\n  const {children, refreshInterval = 10000, token} = props\n\n  if (!props.client) {\n    throw new Error('Missing a `client` prop with a configured Sanity client instance')\n  }\n\n  const perspective = usePerspective(props.perspective || 'drafts')\n\n  // Ensure these values are stable even if userland isn't memoizing properly\n  const [client] = useState(() => {\n    const {requestTagPrefix, resultSourceMap} = props.client.config()\n    return props.client.withConfig({\n      requestTagPrefix: requestTagPrefix || DEFAULT_TAG,\n      resultSourceMap: resultSourceMap === 'withKeyArraySelector' ? 'withKeyArraySelector' : true,\n      // Set the recommended defaults, this is a convenience to make it easier to share a client config from a server component to the client component\n      ...(token && {\n        token,\n        useCdn: false,\n        perspective: 'drafts',\n        ignoreBrowserTokenWarning: true,\n      }),\n    })\n  })\n  const [logger] = useState(() => props.logger)\n\n  useEffect(() => {\n    if (logger) {\n      logger.log(\n        `[@sanity/preview-kit]: With the current configuration you can expect that: Updates that can be traced using Content Source Maps will be applied in real-time. Other updates will be applied every ${refreshInterval}ms.`,\n      )\n    }\n  }, [logger, refreshInterval])\n\n  const [subscriptions, setSubscriptions] = useState<QueryCacheKey[]>([])\n  const [snapshots] = useState<QuerySnapshotsCache>(() => new Map())\n  const hooks = useHooks(setSubscriptions)\n  const [context] = useState<DefineListenerContext>(() => {\n    return function defineListener<QueryResult>(\n      initialSnapshot: QueryResult,\n      query: string,\n      params: QueryParams,\n    ) {\n      const key = getQueryCacheKey(query, params)\n\n      // Warm up the cache by setting the initial snapshot, showing stale-while-revalidate\n      if (!snapshots.has(key)) {\n        snapshots.set(key, {\n          result: initialSnapshot,\n          resultSourceMap: {} as ContentSourceMap,\n        })\n      }\n\n      const subscribe: ListenerSubscribe = (onStoreChange) => {\n        const unsubscribe = hooks.subscribe(key, query, params, onStoreChange)\n\n        return () => unsubscribe()\n      }\n      const getSnapshot: ListenerGetSnapshot<QueryResult> = () =>\n        snapshots.get(key)?.result as unknown as QueryResult\n\n      return {subscribe, getSnapshot}\n    } satisfies DefineListenerContext\n  })\n  const [turboIds, setTurboIds] = useState<string[]>([])\n  const [docsInUse] = useState(() => new Map<string, ContentSourceMapDocuments[number]>())\n  const turboIdsFromSourceMap = useCallback(\n    (contentSourceMap: ContentSourceMap) => {\n      // This handler only adds ids, on each query fetch. But that's ok since <Turbo /> purges ids that are unused\n      const nextTurboIds = new Set<string>()\n      docsInUse.clear()\n      if (contentSourceMap.documents?.length) {\n        for (const document of contentSourceMap.documents) {\n          nextTurboIds.add(document._id)\n          docsInUse.set(document._id, document)\n        }\n      }\n      startTransition(() =>\n        setTurboIds((prevTurboIds) => {\n          const mergedTurboIds = Array.from(new Set([...prevTurboIds, ...nextTurboIds]))\n          if (JSON.stringify(mergedTurboIds.sort()) === JSON.stringify(prevTurboIds.sort())) {\n            return prevTurboIds\n          }\n          return mergedTurboIds\n        }),\n      )\n    },\n    [docsInUse],\n  )\n\n  return (\n    <Context.Provider value={context}>\n      {children}\n      <Turbo\n        cache={hooks.cache}\n        client={client}\n        setTurboIds={setTurboIds}\n        snapshots={snapshots}\n        turboIds={turboIds}\n        docsInUse={docsInUse}\n        perspective={perspective}\n      />\n      {subscriptions.map((key) => {\n        if (!hooks.cache.has(key)) return null\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const {query, params, listeners} = hooks.cache.get(key)!\n        return (\n          <QuerySubscription\n            key={`${key}-${perspective}`}\n            client={client}\n            listeners={listeners}\n            params={params}\n            query={query}\n            refreshInterval={refreshInterval}\n            snapshots={snapshots}\n            turboIdsFromSourceMap={turboIdsFromSourceMap}\n            perspective={perspective}\n          />\n        )\n      })}\n    </Context.Provider>\n  )\n}\nLiveStoreProvider.displayName = 'LiveStoreProvider'\n\ninterface QuerySubscriptionProps\n  extends Required<Pick<LiveQueryProviderProps, 'client' | 'refreshInterval'>> {\n  query: string\n  params: QueryParams\n  listeners: Set<() => void>\n  turboIdsFromSourceMap: (contentSourceMap: ContentSourceMap) => void\n  snapshots: QuerySnapshotsCache\n  perspective: Exclude<ClientPerspective, 'raw'>\n}\nfunction QuerySubscription(props: QuerySubscriptionProps) {\n  const {\n    client,\n    refreshInterval,\n    query,\n    params,\n    listeners,\n    snapshots,\n    turboIdsFromSourceMap,\n    perspective,\n  } = props\n  const {projectId, dataset} = useMemo(() => {\n    const {projectId, dataset} = client.config()\n    return {projectId, dataset} as Required<Pick<ClientConfig, 'projectId' | 'dataset'>>\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({refreshInterval})\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const {signal} = controller\n      const {result, resultSourceMap} = await (client as SanityClient).fetch(query, params, {\n        signal,\n        filterResponse: false,\n        perspective,\n      })\n\n      if (!signal.aborted) {\n        snapshots.set(getQueryCacheKey(query, params), {\n          result: turboChargeResultIfSourceMap(\n            projectId,\n            dataset,\n            result,\n            perspective,\n            resultSourceMap,\n          ),\n          resultSourceMap: resultSourceMap ?? ({} as ContentSourceMap),\n        })\n\n        if (resultSourceMap) {\n          turboIdsFromSourceMap(resultSourceMap)\n        }\n\n        // Notify listeners that snapshots are updated\n        for (const listener of listeners.values()) {\n          listener()\n        }\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    listeners,\n    params,\n    perspective,\n    projectId,\n    query,\n    shouldRefetch,\n    snapshots,\n    startRefresh,\n    turboIdsFromSourceMap,\n  ])\n\n  return null\n}\nQuerySubscription.displayName = 'QuerySubscription'\n\ntype QuerySnapshotsCache = Map<QueryCacheKey, {result: unknown; resultSourceMap: ContentSourceMap}>\n\nfunction getTurboCacheKey(\n  projectId: string,\n  dataset: string,\n  _id: string,\n): `${string}-${string}-${string}` {\n  return `${projectId}-${dataset}-${_id}`\n}\n\ntype LiveStoreQueryCacheMap = Map<\n  QueryCacheKey,\n  {query: string; params: QueryParams; listeners: Set<() => void>}\n>\n\n/**\n * Keeps track of store subscribers per cache key, in a way that's designed for useSyncExternalStore.\n * The main difference from a typical subscription state with useEffect is that `adding` and `cleanup`\n * is wholly managed by the `subscribe` function in `useSyncExternalStore`, instead of lifecycles in useEffect.\n * And since the `onStoreChange` callback, provided to `subscribe`, notifies React when to re-render,\n * there is no need to use `setState` to trigger a re-render. That's why the Map is persisted in `useState` but the state setter isn't used.\n */\nfunction useHooks(setSubscriptions: React.Dispatch<React.SetStateAction<QueryCacheKey[]>>): {\n  cache: LiveStoreQueryCacheMap\n  subscribe: (\n    key: QueryCacheKey,\n    query: string,\n    params: QueryParams,\n    listener: () => void,\n  ) => () => void\n} {\n  const [cache] = useState<LiveStoreQueryCacheMap>(() => new Map())\n  const subscribe = useCallback(\n    (key: QueryCacheKey, query: string, params: QueryParams, listener: () => void) => {\n      if (!cache.has(key)) {\n        cache.set(key, {query, params, listeners: new Set<() => void>()})\n        startTransition(() =>\n          setSubscriptions((prevSubscriptions) => {\n            if (prevSubscriptions.includes(key)) {\n              return prevSubscriptions\n            }\n            return [...prevSubscriptions, key]\n          }),\n        )\n      }\n      const hook = cache.get(key)\n      if (!hook || !hook.listeners) {\n        throw new TypeError('Inconsistent cache for key: ' + key)\n      }\n      const {listeners} = hook\n      listeners.add(listener)\n      return () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          cache.delete(key)\n          startTransition(() =>\n            setSubscriptions((prevSubscriptions) => {\n              if (prevSubscriptions.includes(key)) {\n                return prevSubscriptions.filter((sub) => sub !== key)\n              }\n              return prevSubscriptions\n            }),\n          )\n        }\n      }\n    },\n    [cache, setSubscriptions],\n  )\n  return useMemo(() => ({cache, subscribe}), [cache, subscribe])\n}\n\ninterface TurboProps extends Pick<LiveQueryProviderProps, 'client'> {\n  turboIds: string[]\n  docsInUse: Map<string, ContentSourceMapDocuments[number]>\n  setTurboIds: React.Dispatch<React.SetStateAction<string[]>>\n  cache: LiveStoreQueryCacheMap\n  snapshots: QuerySnapshotsCache\n  perspective: Exclude<ClientPerspective, 'raw'>\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nfunction Turbo(props: TurboProps) {\n  const {client, snapshots, cache, turboIds, setTurboIds, docsInUse, perspective} = props\n  const {projectId, dataset} = useMemo(() => {\n    const {projectId, dataset} = client.config()\n    return {projectId, dataset} as Required<Pick<ClientConfig, 'projectId' | 'dataset'>>\n  }, [client])\n\n  // Keep track of document ids that the active `useLiveQuery` hooks care about\n  useEffect(() => {\n    const nextTurboIds = new Set<string>()\n    docsInUse.clear()\n    for (const {query, params} of cache.values()) {\n      const key = getQueryCacheKey(query, params)\n      const snapshot = snapshots.get(key)\n      if (snapshot && snapshot.resultSourceMap?.documents?.length) {\n        for (const document of snapshot.resultSourceMap.documents) {\n          nextTurboIds.add(document._id)\n          docsInUse.set(document._id, document)\n        }\n      }\n    }\n    const nextTurboIdsSnapshot = [...nextTurboIds].sort()\n    if (JSON.stringify(turboIds) !== JSON.stringify(nextTurboIdsSnapshot)) {\n      startTransition(() => setTurboIds(nextTurboIdsSnapshot))\n    }\n  }, [cache, docsInUse, setTurboIds, snapshots, turboIds])\n\n  // Figure out which documents are misssing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (\n        !batchSet.has(turboId) &&\n        !documentsCache.has(getTurboCacheKey(projectId, dataset, turboId))\n      ) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, 100)\n    if (nextBatchSlice.length === 0) return\n    startTransition(() => setBatch((prevBatch) => [...prevBatch.slice(-100), nextBatchSlice]))\n  }, [batch, dataset, projectId, turboIds])\n\n  const [lastMutatedDocumentId, setLastMutatedDocumentId] = useState<string>()\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = (client as SanityClient)\n      .listen(\n        `*`,\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n          tag: 'turbo',\n        },\n      )\n      .subscribe((update) => {\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const key = getTurboCacheKey(projectId, dataset, update.documentId)\n        const cachedDocument = documentsCache.peek(key)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = {...cachedDocument} as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          documentsCache.set(key, patchedDocument)\n        }\n\n        startTransition(() => setLastMutatedDocumentId(update.documentId))\n      })\n    return () => subscription.unsubscribe()\n  }, [client, dataset, projectId])\n\n  // If the last mutated document is in the list over turboIds then lets apply the source map\n  useEffect(() => {\n    if (!lastMutatedDocumentId || !turboIds.includes(lastMutatedDocumentId)) return\n\n    const updatedKeys: QueryCacheKey[] = []\n    for (const [key, snapshot] of snapshots.entries()) {\n      if (snapshot.resultSourceMap?.documents?.length) {\n        snapshot.result = turboChargeResultIfSourceMap(\n          projectId,\n          dataset,\n          snapshot.result,\n          perspective,\n          snapshot.resultSourceMap,\n        )\n        updatedKeys.push(key)\n      }\n    }\n    for (const updatedKey of updatedKeys) {\n      const listeners = cache.get(updatedKey)?.listeners\n      if (listeners) {\n        for (const listener of listeners) {\n          listener()\n        }\n      }\n    }\n    startTransition(() => setLastMutatedDocumentId(undefined))\n  }, [cache, dataset, lastMutatedDocumentId, perspective, projectId, snapshots, turboIds])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          client={client}\n          projectId={projectId}\n          dataset={dataset}\n          ids={ids}\n        />\n      ))}\n    </>\n  )\n}\nTurbo.displayName = 'Turbo'\n\ninterface GetDocumentsProps extends Pick<LiveQueryProviderProps, 'client'> {\n  projectId: string\n  dataset: string\n  ids: string[]\n}\nfunction GetDocuments(props: GetDocumentsProps) {\n  const {client, projectId, dataset, ids} = props\n\n  useEffect(() => {\n    const missingIds = ids.filter(\n      (id) => !documentsCache.has(getTurboCacheKey(projectId, dataset, id)),\n    )\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          documentsCache.set(getTurboCacheKey(projectId, dataset, doc._id), doc)\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [client, dataset, ids, projectId])\n\n  return null\n}\nGetDocuments.displayName = 'GetDocuments'\n\nlet warnedAboutCrossDatasetReference = false\nfunction turboChargeResultIfSourceMap(\n  projectId: string,\n  dataset: string,\n  result: unknown,\n  perspective: Exclude<ClientPerspective, 'raw'>,\n  resultSourceMap?: ContentSourceMap,\n) {\n  if (!resultSourceMap) return result\n\n  return applySourceDocuments(\n    result,\n    resultSourceMap,\n    (sourceDocument) => {\n      if (sourceDocument._projectId) {\n        // eslint-disable-next-line no-warning-comments\n        // @TODO Handle cross dataset references\n        if (!warnedAboutCrossDatasetReference) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Cross dataset references are not supported yet, ignoring source document',\n            sourceDocument,\n          )\n          warnedAboutCrossDatasetReference = true\n        }\n        return undefined\n      }\n      return documentsCache.get(getTurboCacheKey(projectId, dataset, sourceDocument._id))\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (changedValue: any, {previousValue}) => {\n      if (typeof changedValue === 'string' && typeof previousValue === 'string') {\n        // Preserve stega encoded strings, if they exist\n        const {encoded} = vercelStegaSplit(previousValue)\n        const {cleaned} = vercelStegaSplit(changedValue)\n        return `${encoded}${cleaned}`\n      }\n      return changedValue\n    },\n    perspective,\n  )\n}\n\n/** @internal */\ntype QueryCacheKey = `${string}-${string}`\n/** @internal */\nfunction getQueryCacheKey(query: string, params: QueryParams): QueryCacheKey {\n  return `${query}-${JSON.stringify(params)}`\n}\n"],"names":["_","s","c","v","bf","Context","projectId","dataset","error","vercelStegaSplit"],"mappings":"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","x_google_ignoreList":[0,1]}