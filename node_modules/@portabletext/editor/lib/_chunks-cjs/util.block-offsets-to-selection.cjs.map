{"version":3,"file":"util.block-offsets-to-selection.cjs","sources":["../../src/internal-utils/asserters.ts","../../src/internal-utils/parse-blocks.ts","../../src/utils/util.block-offsets-to-selection.ts"],"sourcesContent":["import type {TypedObject} from '@sanity/types'\n\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n","import type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isTypedObject} from './asserters'\n\nexport function parseBlock({\n  context,\n  block,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  block: unknown\n  options: {\n    refreshKeys: boolean\n  }\n}): PortableTextBlock | undefined {\n  return (\n    parseTextBlock({block, context, options}) ??\n    parseBlockObject({blockObject: block, context, options})\n  )\n}\n\nfunction parseBlockObject({\n  blockObject,\n  context,\n  options,\n}: {\n  blockObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(blockObject)) {\n    return undefined\n  }\n\n  if (\n    blockObject._type === context.schema.block.name ||\n    blockObject._type === 'block' ||\n    !context.schema.blockObjects.some(({name}) => name === blockObject._type)\n  ) {\n    return undefined\n  }\n\n  return {\n    ...blockObject,\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof blockObject._key === 'string'\n        ? blockObject._key\n        : context.keyGenerator(),\n  }\n}\n\nexport function isTextBlock(\n  schema: EditorSchema,\n  block: unknown,\n): block is PortableTextTextBlock {\n  return (\n    parseTextBlock({\n      block,\n      context: {schema, keyGenerator: () => ''},\n      options: {refreshKeys: false},\n    }) !== undefined\n  )\n}\n\nfunction parseTextBlock({\n  block,\n  context,\n  options,\n}: {\n  block: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextTextBlock | undefined {\n  if (!isTypedObject(block)) {\n    return undefined\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return undefined\n  }\n\n  const _key = options.refreshKeys\n    ? context.keyGenerator()\n    : typeof block._key === 'string'\n      ? block._key\n      : context.keyGenerator()\n\n  const unparsedMarkDefs: Array<unknown> = Array.isArray(block.markDefs)\n    ? block.markDefs\n    : []\n  const markDefKeyMap = new Map<string, string>()\n  const markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef)) {\n      return []\n    }\n\n    if (typeof markDef._key !== 'string') {\n      return []\n    }\n\n    if (\n      context.schema.annotations.some(\n        (annotation) => annotation.name === markDef._type,\n      )\n    ) {\n      const _key = options.refreshKeys ? context.keyGenerator() : markDef._key\n      markDefKeyMap.set(markDef._key, _key)\n\n      return [\n        {\n          ...markDef,\n          _key,\n        },\n      ]\n    }\n\n    return []\n  })\n\n  const unparsedChildren: Array<unknown> = Array.isArray(block.children)\n    ? block.children\n    : []\n\n  const children = unparsedChildren\n    .map(\n      (child) =>\n        parseSpan({span: child, context, markDefKeyMap, options}) ??\n        parseInlineObject({inlineObject: child, context, options}),\n    )\n    .filter((child) => child !== undefined)\n\n  const parsedBlock: PortableTextTextBlock = {\n    // Spread the entire block to allow custom properties on it\n    ...block,\n    _key,\n    children:\n      children.length > 0\n        ? children\n        : [\n            {\n              _key: context.keyGenerator(),\n              _type: context.schema.span.name,\n              text: '',\n              marks: [],\n            },\n          ],\n    markDefs,\n  }\n\n  /**\n   * Reset text block .style if it's somehow set to an invalid type\n   */\n  if (\n    typeof parsedBlock.style !== 'string' ||\n    !context.schema.styles.find((style) => style.value === block.style)\n  ) {\n    const defaultStyle = context.schema.styles.at(0)?.value\n\n    if (defaultStyle !== undefined) {\n      parsedBlock.style = defaultStyle\n    } else {\n      delete parsedBlock.style\n    }\n  }\n\n  /**\n   * Reset text block .listItem if it's somehow set to an invalid type\n   */\n  if (\n    typeof parsedBlock.listItem !== 'string' ||\n    !context.schema.lists.find((list) => list.value === block.listItem)\n  ) {\n    delete parsedBlock.listItem\n  }\n\n  /**\n   * Reset text block .level if it's somehow set to an invalid type\n   */\n  if (typeof parsedBlock.level !== 'number') {\n    delete parsedBlock.level\n  }\n\n  return parsedBlock\n}\n\nexport function parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  span: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {refreshKeys: boolean}\n}): PortableTextSpan | undefined {\n  if (!isTypedObject(span)) {\n    return undefined\n  }\n\n  // In reality, the span schema name is always 'span', but we only the check here anyway\n  if (span._type !== context.schema.span.name || span._type !== 'span') {\n    return undefined\n  }\n\n  const unparsedMarks: Array<unknown> = Array.isArray(span.marks)\n    ? span.marks\n    : []\n  const marks = unparsedMarks.flatMap((mark) => {\n    if (typeof mark !== 'string') {\n      return []\n    }\n\n    const markDefKey = markDefKeyMap.get(mark)\n\n    if (markDefKey !== undefined) {\n      return [markDefKey]\n    }\n\n    if (\n      context.schema.decorators.some((decorator) => decorator.value === mark)\n    ) {\n      return [mark]\n    }\n\n    return []\n  })\n\n  return {\n    // Spread the entire span to allow custom properties on it\n    ...span,\n    _type: 'span',\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof span._key === 'string'\n        ? span._key\n        : context.keyGenerator(),\n    text: typeof span.text === 'string' ? span.text : '',\n    marks,\n  }\n}\n\nfunction parseInlineObject({\n  inlineObject,\n  context,\n  options,\n}: {\n  inlineObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(inlineObject)) {\n    return undefined\n  }\n\n  if (\n    inlineObject._type === context.schema.span.name ||\n    inlineObject._type === 'span' ||\n    // Respect the schema definition and don't parse inline objects that are not defined\n    !context.schema.inlineObjects.some(({name}) => name === inlineObject._type)\n  ) {\n    return undefined\n  }\n\n  return {\n    // Spread the entire inline object to allow custom properties on it\n    ...inlineObject,\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof inlineObject._key === 'string'\n        ? inlineObject._key\n        : context.keyGenerator(),\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {BlockOffset} from '../behaviors'\nimport type {EditorSelection} from '../selectors'\nimport {blockOffsetToSpanSelectionPoint} from './util.block-offset'\n\n/**\n * @public\n */\nexport function blockOffsetsToSelection({\n  value,\n  offsets,\n  backward,\n}: {\n  value: Array<PortableTextBlock>\n  offsets: {anchor: BlockOffset; focus: BlockOffset}\n  backward?: boolean\n}): EditorSelection {\n  const anchor = blockOffsetToSpanSelectionPoint({\n    value,\n    blockOffset: offsets.anchor,\n    direction: backward ? 'backward' : 'forward',\n  })\n  const focus = blockOffsetToSpanSelectionPoint({\n    value,\n    blockOffset: offsets.focus,\n    direction: backward ? 'forward' : 'backward',\n  })\n\n  if (!anchor || !focus) {\n    return null\n  }\n\n  return {\n    anchor,\n    focus,\n    backward,\n  }\n}\n"],"names":["isTypedObject","object","isRecord","_type","value","parseBlock","context","block","options","parseTextBlock","parseBlockObject","blockObject","schema","name","blockObjects","some","_key","refreshKeys","keyGenerator","isTextBlock","undefined","unparsedMarkDefs","Array","isArray","markDefs","markDefKeyMap","Map","flatMap","markDef","annotations","annotation","set","children","map","child","parseSpan","span","parseInlineObject","inlineObject","filter","parsedBlock","length","text","marks","style","styles","find","defaultStyle","at","listItem","lists","list","level","mark","markDefKey","get","decorators","decorator","inlineObjects","blockOffsetsToSelection","offsets","backward","anchor","blockOffsetToSpanSelectionPoint","blockOffset","direction","focus"],"mappings":"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"}