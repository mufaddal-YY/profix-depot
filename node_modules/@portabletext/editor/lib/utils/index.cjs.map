{"version":3,"file":"index.cjs","sources":["../../src/utils/util.child-selection-point-to-block-offset.ts","../../src/utils/util.is-text-block.ts","../../src/utils/util.merge-text-blocks.ts","../../src/utils/util.split-text-block.ts"],"sourcesContent":["import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {BlockOffset} from '../behaviors/behavior.types'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function childSelectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const childKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !childKey) {\n    return undefined\n  }\n\n  for (const block of value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (child._key === childKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      if (isPortableTextSpan(child)) {\n        offset += child.text.length\n      }\n    }\n  }\n}\n","import type {PortableTextBlock, PortableTextTextBlock} from '@sanity/types'\nimport type {EditorContext} from '../selectors'\n\n/**\n * @public\n */\nexport function isTextBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: PortableTextBlock,\n): block is PortableTextTextBlock {\n  return block._type === context.schema.block.name\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {parseBlock} from '../internal-utils/parse-blocks'\nimport type {EditorContext} from '../selectors'\nimport {isTextBlock} from './util.is-text-block'\n\n/**\n * @beta\n */\nexport function mergeTextBlocks({\n  context,\n  targetBlock,\n  incomingBlock,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  targetBlock: PortableTextTextBlock\n  incomingBlock: PortableTextTextBlock\n}) {\n  const parsedIncomingBlock = parseBlock({\n    context,\n    block: incomingBlock,\n    options: {refreshKeys: true},\n  })\n\n  if (!parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock)) {\n    return targetBlock\n  }\n\n  return {\n    ...targetBlock,\n    children: [...targetBlock.children, ...parsedIncomingBlock.children],\n    markDefs: [\n      ...(targetBlock.markDefs ?? []),\n      ...(parsedIncomingBlock.markDefs ?? []),\n    ],\n  }\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {isTextBlock, sliceBlocks, type EditorSelectionPoint} from '.'\nimport type {EditorContext} from '../selectors'\nimport {isSpan} from './util.is-span'\n\n/**\n * @beta\n */\nexport function splitTextBlock({\n  context,\n  block,\n  point,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: PortableTextTextBlock\n  point: EditorSelectionPoint\n}): {before: PortableTextTextBlock; after: PortableTextTextBlock} | undefined {\n  const firstChild = block.children.at(0)\n  const lastChild = block.children.at(block.children.length - 1)\n\n  if (!firstChild || !lastChild) {\n    return undefined\n  }\n\n  const before = sliceBlocks({\n    blocks: [block],\n    selection: {\n      anchor: {\n        path: [{_key: block._key}, 'children', {_key: firstChild._key}],\n        offset: 0,\n      },\n      focus: point,\n    },\n  }).at(0)\n  const after = sliceBlocks({\n    blocks: [block],\n    selection: {\n      anchor: point,\n      focus: {\n        path: [{_key: block._key}, 'children', {_key: lastChild._key}],\n        offset: isSpan(context, lastChild) ? lastChild.text.length : 0,\n      },\n    },\n  }).at(0)\n\n  if (!before || !after) {\n    return undefined\n  }\n\n  if (!isTextBlock(context, before) || !isTextBlock(context, after)) {\n    return undefined\n  }\n\n  return {before, after}\n}\n"],"names":["childSelectionPointToBlockOffset","value","selectionPoint","offset","blockKey","isKeyedSegment","path","_key","undefined","childKey","block","isPortableTextTextBlock","child","children","isPortableTextSpan","text","length","isTextBlock","context","_type","schema","name","mergeTextBlocks","targetBlock","incomingBlock","parsedIncomingBlock","parseBlock","options","refreshKeys","markDefs","splitTextBlock","point","firstChild","at","lastChild","before","sliceBlocks","blocks","selection","anchor","focus","after","isSpan"],"mappings":"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"}