"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var util_sliceBlocks = require("../_chunks-cjs/util.slice-blocks.cjs"), util_blockOffsetsToSelection = require("../_chunks-cjs/util.block-offsets-to-selection.cjs"), types = require("@sanity/types"), util_reverseSelection = require("../_chunks-cjs/util.reverse-selection.cjs");
function childSelectionPointToBlockOffset({
  value,
  selectionPoint
}) {
  let offset = 0;
  const blockKey = util_sliceBlocks.isKeyedSegment(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, childKey = util_sliceBlocks.isKeyedSegment(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;
  if (!(!blockKey || !childKey)) {
    for (const block of value)
      if (block._key === blockKey && types.isPortableTextTextBlock(block))
        for (const child of block.children) {
          if (child._key === childKey)
            return {
              path: [{
                _key: block._key
              }],
              offset: offset + selectionPoint.offset
            };
          types.isPortableTextSpan(child) && (offset += child.text.length);
        }
  }
}
function isTextBlock(context, block) {
  return block._type === context.schema.block.name;
}
function mergeTextBlocks({
  context,
  targetBlock,
  incomingBlock
}) {
  const parsedIncomingBlock = util_blockOffsetsToSelection.parseBlock({
    context,
    block: incomingBlock,
    options: {
      refreshKeys: !0
    }
  });
  return !parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock) ? targetBlock : {
    ...targetBlock,
    children: [...targetBlock.children, ...parsedIncomingBlock.children],
    markDefs: [...targetBlock.markDefs ?? [], ...parsedIncomingBlock.markDefs ?? []]
  };
}
function splitTextBlock({
  context,
  block,
  point
}) {
  const firstChild = block.children.at(0), lastChild = block.children.at(block.children.length - 1);
  if (!firstChild || !lastChild)
    return;
  const before = util_sliceBlocks.sliceBlocks({
    blocks: [block],
    selection: {
      anchor: {
        path: [{
          _key: block._key
        }, "children", {
          _key: firstChild._key
        }],
        offset: 0
      },
      focus: point
    }
  }).at(0), after = util_sliceBlocks.sliceBlocks({
    blocks: [block],
    selection: {
      anchor: point,
      focus: {
        path: [{
          _key: block._key
        }, "children", {
          _key: lastChild._key
        }],
        offset: util_sliceBlocks.isSpan(context, lastChild) ? lastChild.text.length : 0
      }
    }
  }).at(0);
  if (!(!before || !after) && !(!isTextBlock(context, before) || !isTextBlock(context, after)))
    return {
      before,
      after
    };
}
exports.blockOffsetToSpanSelectionPoint = util_sliceBlocks.blockOffsetToSpanSelectionPoint;
exports.getBlockEndPoint = util_sliceBlocks.getBlockEndPoint;
exports.getBlockStartPoint = util_sliceBlocks.getBlockStartPoint;
exports.getTextBlockText = util_sliceBlocks.getTextBlockText;
exports.isEmptyTextBlock = util_sliceBlocks.isEmptyTextBlock;
exports.isEqualSelectionPoints = util_sliceBlocks.isEqualSelectionPoints;
exports.isKeyedSegment = util_sliceBlocks.isKeyedSegment;
exports.isSpan = util_sliceBlocks.isSpan;
exports.sliceBlocks = util_sliceBlocks.sliceBlocks;
exports.spanSelectionPointToBlockOffset = util_sliceBlocks.spanSelectionPointToBlockOffset;
exports.blockOffsetsToSelection = util_blockOffsetsToSelection.blockOffsetsToSelection;
exports.reverseSelection = util_reverseSelection.reverseSelection;
exports.childSelectionPointToBlockOffset = childSelectionPointToBlockOffset;
exports.isTextBlock = isTextBlock;
exports.mergeTextBlocks = mergeTextBlocks;
exports.splitTextBlock = splitTextBlock;
//# sourceMappingURL=index.cjs.map
